
## 设计模式原则 ##
- 开闭原则Open Close Principle
	- 对扩展开放，对修改关闭
- 里氏代换原则Liskov Substitution Principle
	- 任何基类可以出现的地方，子类一定可以出现；实现“开-闭”原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现；对实现抽象化的具体步骤的规范
- 依赖倒转原则Dependence Inversion Principle
	- 开闭原则的基础，针对接口编程，依赖于抽象而不依赖于具体；
- 接口隔离原则Interface Segregation Principle
	- 使用多个隔离的接口，比使用单个接口要好；从大型软件架构出发，为了升级和维护方便：降低依赖，降低耦合。
- 迪米特法则（最少知道原则）Demeter Principle
	- 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
- 合成复用原则Composite Reuse Principle
	- 原则是尽量使用合成/聚合的方式，而不是使用继承。
## 1、工厂方法模式 ##
- 普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。
- 多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。
- 静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。
## 2、抽象工厂模式（Abstract Factory） ##
- 工厂方法模式都是通过工厂类来进行创建，一旦需要新的功能，则需要修改工厂类，违背了闭包原则。所以我们新建多个工厂类，并提供多个实现的类来创建工厂类，一旦有新功能，秩序修改单一的工厂类即可。
## 3、单例模式（Singleton） ##
- 单例对象能保证在一个JVM中，该对象只有一个实例存在。
	- 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。
	- 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。
	- 保证核心交易服务器独立控制整个流程。
- 单例模式的类型
	- 懒汉式，线程不安全
	- 懒汉式，线程安全
	- 饿汉式
	- 饿汉式，变种
	- 静态内部类
	- 枚举
	- 双重校验锁
## 4、建造者模式（Builder） ##
- 将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性
## 5、原型模式（Prototype） ##
- 创建型的模式，将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。
- 浅复制：重新创建对象，但是对象的引用不变。
	- 实现Cloneable借口，重新写一个方法，调用super.clone()方法即可
- 深复制：重新创建对象，对应的引用也发生改变。
	- 需要通过字节输入和输出进行
## 6、适配器模式 ##
- 某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题；
	- 类的适配器
		- 将类的方法适配到接口中，使得接口也可使用
		- 当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可
	- 对象的适配器
		- 将对象装载进适配器中
		- 当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。
	- 接口的适配器
		- 根据不同的接口信息，采用不同的方法
		- 当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。
## 7、装饰模式（Decorator） ##
- 装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，
	- 需要扩展一个类的功能。
	- 动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）
	- 缺点：产生过多相似的对象，不易排错！
## 8、代理模式（Proxy） ##
- 代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。
## 9、外观模式（Facade） ##
- 外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，降低了类类之间的耦合度
## 10、桥接模式（Bridge） ##
- 桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化
## 11、组合模式（Composite） ##
- 组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便
- 使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。
## 12、享元模式（Flyweight） ##
- 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。
# 父类与子类 #
## 13、策略模式（strategy） ##
- 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数
## 14、模板方法模式（Template Method） ##
- 一个抽象类中，有一个主方法，再定义1...n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用
# 类与类 #
## 15、观察者模式（Observer）类与类的关系- ##
- 当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系
## 16.迭代子模式 ##
- 迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。
## 17、责任链模式（Chain of Responsibility） ##
- 有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。
## 18、命令模式（Command） ##
- 命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！
# 类的状态 #
## 19、备忘录模式Memento ##
- 主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象
## 20、状态模式State ##
- 核心思想就是：当对象的状态改变时，同时改变其行为
# 通过中间类 #
## 21、访问者模式Visitor ##
- 访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。
## 22、中介模式Mediator ##
- 中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。
## 23、解析器模式 ##

